<application>
  <component name="AppStorage">
    <option name="newTranslationDialogCollapseDictViewer" value="false" />
    <option name="newTranslationDialogHeight" value="322" />
    <option name="newTranslationDialogWidth" value="932" />
    <option name="newTranslationDialogX" value="391" />
    <option name="newTranslationDialogY" value="289" />
    <option name="pinTranslationDialog" value="true" />
    <histories>
      <item value="Log Manager" />
      <item value="不动户判断" />
      <item value="bu" />
      <item value="indicate" />
      <item value="排队" />
      <item value="pai duui" />
      <item value="审核" />
      <item value="build Message" />
      <item value="get Code" />
      <item value="COMM PROC APPLY ERROR" />
      <item value="build Code" />
      <item value="Nethall Err Enum" />
      <item value="Acclogin Resp" />
      <item value="equals" />
      <item value="resp" />
      <item value="verification" />
      <item value="Fund Err Enum" />
      <item value="录入" />
      <item value="Dormant" />
      <item value="basanite" />
      <item value="candidate" />
      <item value="Approve" />
      <item value="大陆" />
      <item value="da lu" />
      <item value="da l" />
      <item value="da" />
      <item value="cancel_dormant" />
      <item value="dormant" />
      <item value="办理" />
      <item value="Returns a comparator that imposes the reverse ordering of this comparator. Returns: a comparator that imposes the reverse ordering of this comparator." />
      <item value="define" />
      <item value="qualifying" />
      <item value="Unsatisfied dependency expressed through bean property" />
      <item value="exploded" />
      <item value="current Time Millis" />
      <item value="Establishing SSL connection without server's identity verification is not recommended" />
      <item value="recommended" />
      <item value="delegate" />
      <item value="baomidou" />
      <item value="Routing Statement Handler" />
      <item value="生成" />
      <item value="generator" />
      <item value="Parent dependency not found, it is probably in the parent pom" />
      <item value="established" />
      <item value="featured" />
      <item value="feature" />
      <item value="精选提问" />
      <item value="精选" />
      <item value="原始" />
      <item value="未处理" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="1179" />
        <entry key="ENGLISH" value="1180" />
        <entry key="AZERBAIJANI" value="1" />
        <entry key="BULGARIAN" value="1" />
        <entry key="DANISH" value="1" />
        <entry key="FRENCH" value="4" />
        <entry key="CATALAN" value="1" />
        <entry key="CROATIAN" value="3" />
        <entry key="ROMANIAN" value="1" />
        <entry key="NORWEGIAN" value="1" />
        <entry key="JAPANESE" value="1" />
        <entry key="TURKISH" value="1" />
        <entry key="WELSH" value="1" />
        <entry key="INDONESIAN" value="3" />
        <entry key="JAVANESE" value="4" />
        <entry key="VIETNAMESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1666245690041" />
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="863505099@qq.com" />
      </app-key>
    </option>
    <option name="primaryFontFamily" value="Ayuthaya" />
    <option name="translateDocumentation" value="true" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="pwvison@163.com" />
      </youdao-translate>
    </option>
  </component>
  <component name="Translation.Cache">
    <option name="lastTrimTime" value="1675157266826" />
  </component>
  <component name="Translation.Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20190706000315257" />
      </app-key>
    </option>
    <option name="primaryLanguage" value="CHINESE" />
    <option name="translator" value="YOUDAO" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="74d984ce3ddacea6" />
      </youdao-translate>
    </option>
  </component>
  <component name="Translation.States">
    <option name="newTranslationDialogHeight" value="395" />
    <option name="newTranslationDialogWidth" value="847" />
    <option name="newTranslationDialogX" value="442" />
    <option name="newTranslationDialogY" value="289" />
    <histories>
      <item value="negate Exact" />
      <item value="capital" />
      <item value="minimumcapital" />
      <item value="SATURDAY" />
      <item value="SUNDAY" />
      <item value="Causes the currently executing thread to sleep (temporarily cease execution) for the specified number of milliseconds, subject to the precision and accuracy of system timers and schedulers. The thread does not lose ownership of any monitors. Params: millis – the length of time to sleep in milliseconds Throws: IllegalArgumentException – if the value of millis is negative InterruptedException – if any thread has interrupted the current thread. The interrupted status of the current thread is cleared when this exception is thrown." />
      <item value="millis" />
      <item value="The problem it is looking at is not that Thread.sleep. That is not the problem. However, intellij's detector of this pattern needs it to find this case, but it is not what it is complaining about, which might be a little hard to wrap your head around.&#10;&#10;What IntelliJ is worried about, is that you're wasting cycles continually rechecking log.isEmpty() for no reason. It has a problem with the while aspect of this code, not the sleep. It would prefer to see code where you invoke some sort of logs.poll() method which will just wait until it is actively woken up by the act of new logs appearing.&#10;&#10;" />
      <item value="The problem it is looking at is not that Thread.sleep. That is not the problem. However, intellij's detector of this pattern needs it to find this case, but it is not what it is complaining about, which might be a little hard to wrap your head around.&#10;&#10;What IntelliJ is worried about, is that you're wasting cycles continually rechecking log.isEmpty() for no reason. It has a problem with the while aspect of this code, not the sleep. It would prefer to see code where you invoke some sort of logs.poll() method which will just wait until it is actively woken up by the act of new logs appearing.&#10;&#10;If this is all running within a single java process, then you can indeed rewrite this entire system (which includes rewrites to whatever log is here, and a complete re-imagining of the checkLogs() method: Instead of going out and checking, whatever is making logs needs to wake up this code instead.&#10;&#10;If it's not, it is likely that you need to tell intellij to shut it: What you are doing is unavoidable without a complete systems redesign.&#10;&#10;The re-interrupt warning&#10;You have some deplorable exception handling here.&#10;&#10;Your exception handling in general&#10;Do not write catch blocks that log something and keep moving. This is really bad error handling: The system's variables and fields are now in an unknown state (you just caught and logged some stuff: Surely that means you have no idea what conditions have occurred to cause this line of execution to happen!), and yet code will move right along. It is extremely likely that 'catch exceptions and just keep going' style code results in more exceptions down the line: Generally, code that operates on unknown state is going to crash and burn sooner rather than later.&#10;&#10;Then, if that crash-and-burn is dealt with in the same fashion (catch it, log it, keep going), then you get another crash-and-burn. You end up with code that will, upon hitting a problem, print 186 exceptions to the log and they are all utterly irrelevant except the first one. That's bad yuyu.&#10;&#10;You're also making it completely impossible for calling code to recover. The point of exceptions is that they need to bubble upwards endlessly: Either the exception is caught by code that actually knows how to deal with the problem (and logging it is not dealing with it!), which you are making impossible, or, the code exception should bubble up all the way to the entry-point handler which is the right place to log the error and abort the entry-point handler.&#10;&#10;An entry-point handler is a generic module or application runner; out of the box, the code baked into java.exe itself that ends up invoking your psv main() method is the most obvious 'entry point runner', but there's more: Web frameworks will eventually invoke some code of yours that is supposed to handle a web request: That code of yours is analogous to psv main(): It is the entry-point, and the code in the web framework that invokes it, is the entry-point runner.&#10;&#10;Entry-point runners have a good reason to catch (Throwable t), and to spend their catch block primarily logging it, though they should generally log a lot more than just the exception (a web handler should for example log the request details, such as which HTTP params were sent and which path request it was, maybe the headers, etc). Any other code should never do this, though.&#10;&#10;If you have no idea what to do and don't want to think about what that exception might mean, the correct 'whatever, just compile already javac' code strategy is to add the exception type to your throws line. If that is not feasible, the right code in the catch block is:&#10;&#10;} catch (ExceptionIDoNotWantToThinkAboutRightNow e) {&#10;    throw new RuntimeException(&quot;Uncaught&quot;, e);&#10;}&#10;This will ensure that code will not just merrily continue onwards, operating on unknown state, and will ensure you get complete details in logs, and ensures that calling code can catch and deal with it if it can, and ensures that any custom logging info such as the HTTP request details get a chance to make it to the logs. Win-win-win-win.&#10;&#10;This case in particular: What does InterruptedEx mean?&#10;When some code running in that java process invokes yourThread.interrupt(), that is how InterruptedException can happen, and it cannot possibly happen in any other way. If the user hits CTRL+C, or goes into task manager and clicks 'end process', or if your android phone decides it is time for your app to get out as the memory is needed for something else - none of those cases can possibly result in InterruptedExceptions. Your threads just get killed midstep by java (if you want to act on shutdowns, use Runtime.getRuntime().addShutdownHook). The only way is for some code to call .interrupt(), and nothing in the core libs is going to do that. Thus, InterruptedException means whatever you think 'call .interrupt() on this thread' means. It is up to you.&#10;&#10;The most common definition is effectively 'I ask you to stop': Just shut down the thread nicely. Generally it is bad to try to shut down threads nicely if you want to exit the entire VM (just invoke System.shutdown - you already need to deal with users hitting CTRL+C, why write shutdown code twice in different ways?) - but sometimes you just want one thread to stop. So, usually the best code to put in a catch (InterruptedException e) block is just return; and nothing else. Don't log anything: The 'interrupt' is intentional: You wrote it. Most likely that is nowhere in your code base and the InterruptedException is moot: It won't ever happen.&#10;&#10;In your specific code, what happens if your code decides to stop the logger thread is that the logger thread will log something to the error logs, and will then shortcut its 2 second wait period to immediately check the logs, and then just keeps going. That sounds completely useless.&#10;&#10;But, it means whatever you want it to. If you want an ability for e.g. the user to hit a 'force check the logs right now' button, then you can define that interrupting the logging thread just shortcuts the 2 seconds (but then just have an empty catch block with a comment explaining that this is how you designed it, obviously don't log it). If you ALSO want a button to 'stop the logging thread', have an AtomicBoolean that tracks 'running' state: When the 'stop log-refreshes' button is hit, set the AB to 'false' and then interrupt the thread: Then the code you pasted needs to check the AB and return; to close the thread if it is false." />
      <item value="The busy-waiting warning&#10;This is a warning coming from intellij that is dubious, in the sense that what you're doing is often just straight up required. In other words, it is detecting a pattern that is overused, but whose usage cannot be reduced to 0. So, likely the right solution is to just tell intellij to shut up about it here.&#10;&#10;" />
      <item value="The busy-waiting warning&#10;This is a warning coming from intellij that is dubious, in the sense that what you're doing is often just straight up required. In other words, it is detecting a pattern that is overused, but whose usage cannot be reduced to 0. So, likely the right solution is to just tell intellij to shut up about it here.&#10;&#10;The problem it is looking at is not that Thread.sleep. That is not the problem. However, intellij's detector of this pattern needs it to find this case, but it is not what it is complaining about, which might be a little hard to wrap your head around.&#10;&#10;What IntelliJ is worried about, is that you're wasting cycles continually rechecking log.isEmpty() for no reason. It has a problem with the while aspect of this code, not the sleep. It would prefer to see code where you invoke some sort of logs.poll() method which will just wait until it is actively woken up by the act of new logs appearing.&#10;&#10;If this is all running within a single java process, then you can indeed rewrite this entire system (which includes rewrites to whatever log is here, and a complete re-imagining of the checkLogs() method: Instead of going out and checking, whatever is making logs needs to wake up this code instead.&#10;&#10;If it's not, it is likely that you need to tell intellij to shut it: What you are doing is unavoidable without a complete systems redesign.&#10;&#10;The re-interrupt warning&#10;You have some deplorable exception handling here.&#10;&#10;Your exception handling in general&#10;Do not write catch blocks that log something and keep moving. This is really bad error handling: The system's variables and fields are now in an unknown state (you just caught and logged some stuff: Surely that means you have no idea what conditions have occurred to cause this line of execution to happen!), and yet code will move right along. It is extremely likely that 'catch exceptions and just keep going' style code results in more exceptions down the line: Generally, code that operates on unknown state is going to crash and burn sooner rather than later.&#10;&#10;Then, if that crash-and-burn is dealt with in the same fashion (catch it, log it, keep going), then you get another crash-and-burn. You end up with code that will, upon hitting a problem, print 186 exceptions to the log and they are all utterly irrelevant except the first one. That's bad yuyu.&#10;&#10;You're also making it completely impossible for calling code to recover. The point of exceptions is that they need to bubble upwards endlessly: Either the exception is caught by code that actually knows how to deal with the problem (and logging it is not dealing with it!), which you are making impossible, or, the code exception should bubble up all the way to the entry-point handler which is the right place to log the error and abort the entry-point handler.&#10;&#10;An entry-point handler is a generic module or application runner; out of the box, the code baked into java.exe itself that ends up invoking your psv main() method is the most obvious 'entry point runner', but there's more: Web frameworks will eventually invoke some code of yours that is supposed to handle a web request: That code of yours is analogous to psv main(): It is the entry-point, and the code in the web framework that invokes it, is the entry-point runner.&#10;&#10;Entry-point runners have a good reason to catch (Throwable t), and to spend their catch block primarily logging it, though they should generally log a lot more than just the exception (a web handler should for example log the request details, such as which HTTP params were sent and which path request it was, maybe the headers, etc). Any other code should never do this, though.&#10;&#10;If you have no idea what to do and don't want to think about what that exception might mean, the correct 'whatever, just compile already javac' code strategy is to add the exception type to your throws line. If that is not feasible, the right code in the catch block is:&#10;&#10;} catch (ExceptionIDoNotWantToThinkAboutRightNow e) {&#10;    throw new RuntimeException(&quot;Uncaught&quot;, e);&#10;}&#10;This will ensure that code will not just merrily continue onwards, operating on unknown state, and will ensure you get complete details in logs, and ensures that calling code can catch and deal with it if it can, and ensures that any custom logging info such as the HTTP request details get a chance to make it to the logs. Win-win-win-win.&#10;&#10;This case in particular: What does InterruptedEx mean?&#10;When some code running in that java process invokes yourThread.interrupt(), that is how InterruptedException can happen, and it cannot possibly happen in any other way. If the user hits CTRL+C, or goes into task manager and clicks 'end process', or if your android phone decides it is time for your app to get out as the memory is needed for something else - none of those cases can possibly result in InterruptedExceptions. Your threads just get killed midstep by java (if you want to act on shutdowns, use Runtime.getRuntime().addShutdownHook). The only way is for some code to call .interrupt(), and nothing in the core libs is going to do that. Thus, InterruptedException means whatever you think 'call .interrupt() on this thread' means. It is up to you.&#10;&#10;The most common definition is effectively 'I ask you to stop': Just shut down the thread nicely. Generally it is bad to try to shut down threads nicely if you want to exit the entire VM (just invoke System.shutdown - you already need to deal with users hitting CTRL+C, why write shutdown code twice in different ways?) - but sometimes you just want one thread to stop. So, usually the best code to put in a catch (InterruptedException e) block is just return; and nothing else. Don't log anything: The 'interrupt' is intentional: You wrote it. Most likely that is nowhere in your code base and the InterruptedException is moot: It won't ever happen.&#10;&#10;In your specific code, what happens if your code decides to stop the logger thread is that the logger thread will log something to the error logs, and will then shortcut its 2 second wait period to immediately check the logs, and then just keeps going. That sounds completely useless.&#10;&#10;But, it means whatever you want it to. If you want an ability for e.g. the user to hit a 'force check the logs right now' button, then you can define that interrupting the logging thread just shortcuts the 2 seconds (but then just have an empty catch block with a comment explaining that this is how you designed it, obviously don't log it). If you ALSO want a button to 'stop the logging thread', have an AtomicBoolean that tracks 'running' state: When the 'stop log-refreshes' button is hit, set the AB to 'false' and then interrupt the thread: Then the code you pasted needs to check the AB and return; to close the thread if it is false." />
      <item value="Call to 'Thread.sleep()' in a loop, probably busy-waiting " />
      <item value="get Next Marker" />
      <item value="object Listing" />
      <item value="Margin Info Req" />
      <item value="this product contains nicotine. Nicotine is an addictive chemical" />
      <item value="this product contains nicotine. Nicotine is an addictive " />
      <item value="this product contains nicotine. Nicotine is an addic" />
      <item value="this product contains nicotine. Nic" />
      <item value="this product contains nicotine. Ni" />
      <item value="this product contains nicotine. N" />
      <item value="this product contains nicotine. Noti" />
      <item value="this product contains nicotine" />
      <item value="this product contains nicoti" />
      <item value="this product contains nico" />
      <item value="this product contains nic" />
      <item value="this product contains" />
      <item value="Control" />
      <item value="风控" />
      <item value="market Switch" />
      <item value="The class String includes methods for examining individual characters of the sequence, for comparing strings, for searching strings, for extracting substrings, and for creating a copy of a string with all characters translated to uppercase or to lowercase. Case mapping is based on the Unicode Standard version specified by the Character class. The Java language provides special support for the string concatenation operator ( + ), and for conversion of other objects to strings. String concatenation is implemented through the StringBuilder(or StringBuffer) class and its append method. String conversions are implemented through the method toString, defined by Object and inherited by all classes in Java. For additional information on string concatenation and conversion, see Gosling, Joy, and Steele, The Java Language Specification. Unless otherwise noted, passing a null argument to a constructor or method in this class will cause a NullPointerException to be thrown. A String represents a string in the UTF-16 format in which supplementary characters are represented by surrogate pairs (see the section Unicode Character Representations in the Character class for more information). Index values refer to char code units, so a supplementary character uses two positions in a String. The String class provides methods for dealing with Unicode code points (i.e., characters), in addition to those for dealing with Unicode code units (i.e., char values)." />
      <item value="user Id" />
      <item value="set Operation Action Type" />
      <item value="Logs Constant" />
      <item value="LOG OPERATION TYPE DORMANT" />
      <item value="build Operation Log" />
      <item value="Security User Operation Log" />
      <item value="sdfsdf" />
      <item value="String" />
      <item value="use serialVersionUID from JDK 1.0.2 for interoperability" />
      <item value="apply Status" />
      <item value="Cancel Dormant Info Resp" />
      <item value="Sea memory confidant" />
      <item value="海内存知己" />
      <item value="hai nei cun zhi" />
      <item value="request Account Fetch" />
      <item value="get Account Identity By Account No" />
      <item value="account no" />
      <item value="is Dormant" />
      <item value="Id Card Util" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="AFRIKAANS" value="1" />
        <entry key="CHINESE" value="29" />
        <entry key="ENGLISH" value="27" />
        <entry key="FRENCH" value="1" />
      </map>
    </option>
  </component>
</application>