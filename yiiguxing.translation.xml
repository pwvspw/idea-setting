<application>
  <component name="AppStorage">
    <histories>
      <item value="insert User Market Expire" />
      <item value="After resolving conflicts you also probably would want to commit your files to the current branch" />
      <item value="You have to resolve all merge conflicts before checkout" />
      <item value="conflicts" />
      <item value="String" />
      <item value="Advertise List Req" />
      <item value="Advertise Resp" />
      <item value="integrates" />
      <item value="easy way for analyzing and excluding conflicting dependencies" />
      <item value="get Context Class Loader" />
      <item value="args" />
      <item value="Base of synchronization control for this lock. Subclassed * into fair and nonfair versions below. Uses AQS state to * represent the number of holds on the lock." />
      <item value="Inspection info: Reports explicit assigning default value to an annotation parameter." />
      <item value="Redundant default parameter value assignment less... (⌃F1)" />
      <item value="This inspection points out the cases where a variable value is never used after its assignment, i.e.:  - the variable never gets read after assignment OR  - the value is always overwritten with another assignment before the next variable read OR  - the variable initializer is redundant (for one of the above two reasons)" />
      <item value="Variable 'queryResult' initializer 'new MsgQueryResult()' is redundant" />
      <item value="Creates a StringEntity with the specified content. The content type defaults to" />
      <item value="Modifier 'final' is redundant for interface fields" />
      <item value="The form of nextInt used by IntStream Spliterators. * For the unbounded case: uses nextInt(). * For the bounded case with representable range: uses nextInt(int bound) * For the bounded case with unrepresentable range: uses nextInt()" />
      <item value="pseudorandom" />
      <item value="The form of nextInt used by IntStream Spliterators. * For the unbounded case: uses nextInt(). * For the bounded case with representable range: uses nextInt(int bound) * For the bounded case with unrepresentable range: uses nextInt(" />
      <item value="Returns the correctly rounded positive square root of a * {@code double} value." />
      <item value="Constructs an empty &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance with the * specified initial capacity, load factor and ordering mode." />
      <item value="ensure Capacity Internal" />
      <item value="Appends the specified element to the end of this list" />
      <item value="Increments modCount" />
      <item value="A hash table supporting full concurrency of retrievals and * high expected concurrency for updates. This class obeys the * same functional specification as {@link java.util.Hashtable}, and * includes versions of methods corresponding to each method of * {@code Hashtable}. However, even though all operations are * thread-safe, retrieval operations do &lt;em&gt;not&lt;/em&gt; entail locking, * and there is &lt;em&gt;not&lt;/em&gt; any support for locking the entire table * in a way that prevents all access. This class is fully * interoperable with {@code Hashtable} in programs that rely on its * thread safety but not on its synchronization details. * * &lt;p&gt;Retrieval operations (including {@code get}) generally do not * block, so may overlap with update operations (including {@code put} * and {@code remove}). Retrievals reflect the results of the most * recently &lt;em&gt;completed&lt;/em&gt; update operations holding upon their * onset. (More formally, an update operation for a given key bears a * &lt;em&gt;happens-before&lt;/em&gt; relation with any (non-null) retrieval for * that key reporting the updated value.) For aggregate operations * such as {@code putAll} and {@code clear}, concurrent retrievals may * reflect insertion or removal of only some entries. Similarly, * Iterators, Spliterators and Enumerations return elements reflecting the * state of the hash table at some point at or since the creation of the * iterator/enumeration. They do &lt;em&gt;not&lt;/em&gt; throw {@link * java.util.ConcurrentModificationException ConcurrentModificationException}. * However, iterators are designed to be used by only one thread at a time. * Bear in mind that the results of aggregate status methods including * {@code size}, {@code isEmpty}, and {@code containsValue} are typically * useful only when a map is not undergoing concurrent updates in other threads. * Otherwise the results of these methods reflect transient states * that may be adequate for monitoring or estimation purposes, but not * for program control. * * &lt;p&gt;The table is dynamically expanded when there are too many * collisions (i.e., keys that have distinct hash codes but fall into * the same slot modulo the table size), with the expected average * effect of maintaining roughly two bins per mapping (corresponding * to a 0.75 load factor threshold for resizing). There may be much * variance around this average as mappings are added and removed, but * overall, this maintains a commonly accepted time/space tradeoff for * hash tables. However, resizing this or any other kind of hash * table may be a relatively slow operation. When possible, it is a * good idea to provide a size estimate as an optional {@code * initialCapacity} constructor argument. An additional optional * {@code loadFactor} constructor argument provides a further means of * customizing initial table capacity by specifying the table density * to be used in calculating the amount of space to allocate for the * given number of elements. Also, for compatibility with previous * versions of this class, constructors may optionally specify an * expected {@code concurrencyLevel} as an additional hint for * internal sizing. Note that using many keys with exactly the same * {@code hashCode()} is a sure way to slow down performance of any * hash table. To ameliorate impact, when keys are {@link Comparable}, * this class may use comparison order among keys to help break ties. * * &lt;p&gt;A {@link Set} projection of a ConcurrentHashMap may be created * (using {@link #newKeySet()} or {@link #newKeySet(int)}), or viewed * (using {@link #keySet(Object)} when only keys are of interest, and the * mapped values are (perhaps transiently) not used or all take the * same mapping value. * * &lt;p&gt;A ConcurrentHashMap can be used as scalable frequency map (a * form of histogram or multiset) by using {@link * java.util.concurrent.atomic.LongAdder} values and initializing via * {@link #computeIfAbsent computeIfAbsent}. For example, to add a count * to a {@code ConcurrentHashMap&lt;String,LongAdder&gt; freqs}, you can use * {@code freqs.computeIfAbsent(k -&gt; new LongAdder()).increment();} * * &lt;p&gt;This class and its views and iterators implement all of the * &lt;em&gt;optional&lt;/em&gt; methods of the {@link Map} and {@link Iterator} * interfaces. * * &lt;p&gt;Like {@link Hashtable} but unlike {@link HashMap}, this class * does &lt;em&gt;not&lt;/em&gt; allow {@code null} to be used as a key or value. * * &lt;p&gt;ConcurrentHashMaps support a set of sequential and parallel bulk * operations that, unlike most {@link Stream} methods, are designed * to be safely, and often sensibly, applied even with maps that are * being concurrently updated by other threads; for example, when * computing a snapshot summary of the values in a shared registry. * There are three kinds of operation, each with four forms, accepting * functions with Keys, Values, Entries, and (Key, Value) arguments * and/or return values. Because the elements of a ConcurrentHashMap * are not ordered in any particular way, and may be processed in * different orders in different parallel executions, the correctness * of supplied functions should not depend on any ordering, or on any * other objects or values that may transiently change while * computation is in progress; and except for forEach actions, should * ideally be side-effect-free. Bulk operations on {@link java.util.Map.Entry} * objects do not support method {@code setValue}. * * &lt;ul&gt; * &lt;li&gt; forEach: Perform a given action on each element. * A variant form applies a given transformation on each element * before performing the action.&lt;/li&gt; * * &lt;li&gt; search: Return the first available non-null result of * applying a given function on each element; skipping further * search when a result is found.&lt;/li&gt; * * &lt;li&gt; reduce: Accumulate each element. The supplied reduction * function cannot rely on ordering (more formally, it should be * both associative and commutative). There are five variants: * * &lt;ul&gt; * * &lt;li&gt; Plain reductions. (There is not a form of this method for * (key, value) function arguments since there is no corresponding * return type.)&lt;/li&gt; * * &lt;li&gt; Mapped reductions that accumulate the results of a given * function applied to each element.&lt;/li&gt; * * &lt;li&gt; Reductions to scalar doubles, longs, and ints, using a * given basis value.&lt;/li&gt; * * &lt;/ul&gt; * &lt;/li&gt; * &lt;/ul&gt; * * &lt;p&gt;These bulk operations accept a {@code parallelismThreshold} * argument. Methods proceed sequentially if the current map size is * estimated to be less than the given threshold. Using a value of * {@code Long.MAX_VALUE} suppresses all parallelism. Using a value * of {@code 1} results in maximal parallelism by partitioning into * enough subtasks to fully utilize the {@link * ForkJoinPool#commonPool()} that is used for all parallel * computations. Normally, you would initially choose one of these * extreme values, and then measure performance of using in-between * values that trade off overhead versus throughput. * * &lt;p&gt;The concurrency properties of bulk operations follow * from those of ConcurrentHashMap: Any non-null result returned * from {@code get(key)} and related access methods bears a * happens-before relation with the associated insertion or * update. The result of any bulk operation reflects the * composition of these per-element relations (but is not * necessarily atomic with respect to the map as a whole unless it * is somehow known to be quiescent). Conversely, because keys * and values in the map are never null, null serves as a reliable * atomic indicator of the current lack of any result. To * maintain this property, null serves as an implicit basis for * all non-scalar reduction operations. For the double, long, and * int versions, the basis should be one that, when combined with * any other value, returns that other value (more formally, it * should be the identity element for the reduction). Most common * reductions have these properties; for example, computing a sum * with basis 0 or a minimum with basis MAX_VALUE. * * &lt;p&gt;Search and transformation functions provided as arguments * should similarly return null to indicate the lack of any result * (in which case it is not used). In the case of mapped * reductions, this also enables transformations to serve as * filters, returning null (or, in the case of primitive * specializations, the identity basis) if the element should not * be combined. You can create compound transformations and * filterings by composing them yourself under this &quot;null means * there is nothing there now&quot; rule before using them in search or * reduce operations. * * &lt;p&gt;Methods accepting and/or returning Entry arguments maintain * key-value associations. They may be useful for example when * finding the key for the greatest value. Note that &quot;plain&quot; Entry * arguments can be supplied using {@code new * AbstractMap.SimpleEntry(k,v)}. * * &lt;p&gt;Bulk operations may complete abruptly, throwing an * exception encountered in the application of a supplied * function. Bear in mind when handling such exceptions that other * concurrently executing functions could also have thrown * exceptions, or would have done so if the first exception had * not occurred. * * &lt;p&gt;Speedups for parallel compared to sequential forms are common * but not guaranteed. Parallel operations involving brief functions * on small maps may execute more slowly than sequential forms if the * underlying work to parallelize the computation is more expensive * than the computation itself. Similarly, parallelization may not * lead to much actual parallelism if all processors are busy * performing unrelated tasks." />
      <item value="his class implements a hash table, which maps keys to values. Any * non-&lt;code&gt;null&lt;/code&gt; object can be used as a key or as a value. &lt;p&gt; * * To successfully store and retrieve objects from a hashtable, the * objects used as keys must implement the &lt;code&gt;hashCode&lt;/code&gt; * method and the &lt;code&gt;equals&lt;/code&gt; method. &lt;p&gt; * * An instance of &lt;code&gt;Hashtable&lt;/code&gt; has two parameters that affect its * performance: &lt;i&gt;initial capacity&lt;/i&gt; and &lt;i&gt;load factor&lt;/i&gt;. The * &lt;i&gt;capacity&lt;/i&gt; is the number of &lt;i&gt;buckets&lt;/i&gt; in the hash table, and the * &lt;i&gt;initial capacity&lt;/i&gt; is simply the capacity at the time the hash table * is created. Note that the hash table is &lt;i&gt;open&lt;/i&gt;: in the case of a &quot;hash * collision&quot;, a single bucket stores multiple entries, which must be searched * sequentially. The &lt;i&gt;load factor&lt;/i&gt; is a measure of how full the hash * table is allowed to get before its capacity is automatically increased. * The initial capacity and load factor parameters are merely hints to * the implementation. The exact details as to when and whether the rehash * method is invoked are implementation-dependent.&lt;p&gt; * * Generally, the default load factor (.75) offers a good tradeoff between * time and space costs. Higher values decrease the space overhead but * increase the time cost to look up an entry (which is reflected in most * &lt;tt&gt;Hashtable&lt;/tt&gt; operations, including &lt;tt&gt;get&lt;/tt&gt; and &lt;tt&gt;put&lt;/tt&gt;).&lt;p&gt; * * The initial capacity controls a tradeoff between wasted space and the * need for &lt;code&gt;rehash&lt;/code&gt; operations, which are time-consuming. * No &lt;code&gt;rehash&lt;/code&gt; operations will &lt;i&gt;ever&lt;/i&gt; occur if the initial * capacity is greater than the maximum number of entries the * &lt;tt&gt;Hashtable&lt;/tt&gt; will contain divided by its load factor. However, * setting the initial capacity too high can waste space.&lt;p&gt; * * If many entries are to be made into a &lt;code&gt;Hashtable&lt;/code&gt;, * creating it with a sufficiently large capacity may allow the * entries to be inserted more efficiently than letting it perform * automatic rehashing as needed to grow the table. &lt;p&gt;" />
      <item value="Atomically updates the current value with the results of" />
      <item value="get And Set Object" />
      <item value="alternative" />
      <item value="Guidelines" />
      <item value="Direct Byte Buffer" />
      <item value="The new buffer's position will be zero, its limit will be its * capacity, its mark will be undefined, and each of its elements will be * initialized to zero. Whether or not it has a * {@link #hasArray backing array} is unspecified." />
      <item value="Allocates a new direct byte buffer" />
      <item value="Compact" />
      <item value="sweep" />
      <item value="Since its first release, the Key Promoter X has about 300.000 downloads. It is top-rated on the JetBrains site, and since it is entirely open-source, other plugin developers can browse through the code to understand how things are implemented. The plugin is not for me or a by-product of something I would do anyway. It is for you who want to learn shortcuts in IntelliJ IDEA, and I give away some of my free time to keep it up to date and fix bugs. If you appreciate my efforts, then please donate some money. And don't forget to star the GitHub repository and leave a rating on the JetBrains plugin site. If you want to see IntelliJ plugin development, fixing bugs or interesting projects live on Twitch, you can turn on when I stream." />
      <item value="Since its first release, the Key Promoter X has about 300.000 downloads. It is top-rated on the JetBrains site, and since it is entirely open-source, other plugin developers can browse through the code to understand how things are implemented.&#10;The plugin is not for me or a by-product of something I would do anyway. It is for you who want to learn shortcuts in IntelliJ IDEA, and I give away some of my free time to keep it up to date and fix bugs. If you appreciate my efforts, then please donate some money. And don't forget to star the GitHub repository and leave a rating on the JetBrains plugin site.&#10;If you want to see IntelliJ plugin development, fixing bugs or interesting projects live on Twitch, you can turn on when I stream." />
      <item value="Reports any uses of parameterized classes where the type parameters are omitted. Such raw uses of parameterized types are valid in Java, but defeat the purpose of using type parameters, and may mask bugs. This inspection mirrors the rawtypes warning of javac. This inspection only reports if the project or module is configured to use a language level of 5.0 or higher. Use the first checkbox below to ignore the construction of objects of parameterized types. Use the second checkbox below to ignore raw types in type casts. Use the third checkbox to ignore raw types in places where parameterized types would not be compilable (for example in array creation expressions or when overriding a library method) Use the fourth checkbox to ignore raw types used in the parameters of methods overriding super methods." />
      <item value="Reports any uses of parameterized classes where the type parameters are omitted. Such raw uses of parameterized types are valid in Java, but defeat the purpose of using type parameters, and may mask bugs. This inspection mirrors the rawtypes warning of javac.&#10;This inspection only reports if the project or module is configured to use a language level of 5.0 or higher. Use the first checkbox below to ignore the construction of objects of parameterized types.&#10;Use the second checkbox below to ignore raw types in type casts.&#10;Use the third checkbox to ignore raw types in places where parameterized types would not be compilable (for example in array creation expressions or when overriding a library method)&#10;Use the fourth checkbox to ignore raw types used in the parameters of methods overriding super methods." />
      <item value="dot" />
      <item value="native" />
      <item value="If this thread was constructed using a separate" />
      <item value="Thread Pool Executor" />
      <item value="bloc" />
      <item value="group" />
      <item value="attempt" />
      <item value="Collections" />
      <item value="Unmodifiable Navigable Set" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="197" />
        <entry key="ENGLISH" value="198" />
        <entry key="FRENCH" value="1" />
        <entry key="ROMANIAN" value="1" />
        <entry key="NORWEGIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="863505099@qq.com" />
        <option name="appKeyConfigured" value="true" />
      </app-key>
    </option>
    <option name="ignoreRegExp" value="" />
    <option name="primaryFontFamily" value="Ayuthaya" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="pwvison@163.com" />
        <option name="appKeyConfigured" value="true" />
      </youdao-translate>
    </option>
  </component>
</application>