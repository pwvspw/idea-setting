<application>
  <component name="AppStorage">
    <histories>
      <item value="but not by operations * on the collection-views of" />
      <item value="Access time is reset by all cache read and write operations" />
      <item value="he most recent replacement of its value, or its last * access" />
      <item value="Specifies that each entry should be automatically removed from the cache once a fixed duration * has elapsed after the entry's creation" />
      <item value="conjunction" />
      <item value="This feature cannot be used in conjunction with {" />
      <item value="temporarily" />
      <item value="or to disable caching temporarily without a code change" />
      <item value="This can be useful in testing" />
      <item value="elements will be evicted immediately after being loaded into the * cache" />
      <item value="it hasn't been used recently or very often" />
      <item value="entries" />
      <item value="evicts" />
      <item value="As the cache size grows close to the maximum" />
      <item value="exceeded" />
      <item value="evict" />
      <item value="Note that" />
      <item value="Specifies the maximum number of entries the cache may contain" />
      <item value="Specifies" />
      <item value="labbder" />
      <item value="labbders" />
      <item value="Specifies that each entry should be automatically removed from the cache once a fixed duration * has elapsed after the entry's creation, the most recent replacement of its value, or its last * access. Access time is reset by all cache read and write operations (including * {@code Cache.asMap().get(Object)} and {@code Cache.asMap().put(K, V)}), but not by operations * on the collection-views of {@link Cache#asMap}. * * &lt;p&gt;When {@code duration} is zero, this method hands off to * {@link #maximumSize(long) maximumSize}{@code (0)}, ignoring any otherwise-specificed maximum * size or weight. This can be useful in testing, or to disable caching temporarily without a code * change. * * &lt;p&gt;Expired entries may be counted in {@link Cache#size}, but will never be visible to read or * write operations. Expired entries are cleaned up as part of the routine maintenance described * in the class javadoc." />
      <item value="expire After Access" />
      <item value="Cache Builder" />
      <item value="nethall market pkg ladder" />
      <item value="insert User Market Expire" />
      <item value="After resolving conflicts you also probably would want to commit your files to the current branch" />
      <item value="You have to resolve all merge conflicts before checkout" />
      <item value="conflicts" />
      <item value="String" />
      <item value="Advertise List Req" />
      <item value="Advertise Resp" />
      <item value="integrates" />
      <item value="easy way for analyzing and excluding conflicting dependencies" />
      <item value="get Context Class Loader" />
      <item value="args" />
      <item value="Base of synchronization control for this lock. Subclassed * into fair and nonfair versions below. Uses AQS state to * represent the number of holds on the lock." />
      <item value="Inspection info: Reports explicit assigning default value to an annotation parameter." />
      <item value="Redundant default parameter value assignment less... (⌃F1)" />
      <item value="This inspection points out the cases where a variable value is never used after its assignment, i.e.:  - the variable never gets read after assignment OR  - the value is always overwritten with another assignment before the next variable read OR  - the variable initializer is redundant (for one of the above two reasons)" />
      <item value="Variable 'queryResult' initializer 'new MsgQueryResult()' is redundant" />
      <item value="Creates a StringEntity with the specified content. The content type defaults to" />
      <item value="Modifier 'final' is redundant for interface fields" />
      <item value="The form of nextInt used by IntStream Spliterators. * For the unbounded case: uses nextInt(). * For the bounded case with representable range: uses nextInt(int bound) * For the bounded case with unrepresentable range: uses nextInt()" />
      <item value="pseudorandom" />
      <item value="The form of nextInt used by IntStream Spliterators. * For the unbounded case: uses nextInt(). * For the bounded case with representable range: uses nextInt(int bound) * For the bounded case with unrepresentable range: uses nextInt(" />
      <item value="Returns the correctly rounded positive square root of a * {@code double} value." />
      <item value="Constructs an empty &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance with the * specified initial capacity, load factor and ordering mode." />
      <item value="ensure Capacity Internal" />
      <item value="Appends the specified element to the end of this list" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="222" />
        <entry key="ENGLISH" value="223" />
        <entry key="FRENCH" value="1" />
        <entry key="ROMANIAN" value="1" />
        <entry key="NORWEGIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="863505099@qq.com" />
        <option name="appKeyConfigured" value="true" />
      </app-key>
    </option>
    <option name="ignoreRegExp" value="" />
    <option name="primaryFontFamily" value="Ayuthaya" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="pwvison@163.com" />
        <option name="appKeyConfigured" value="true" />
      </youdao-translate>
    </option>
  </component>
</application>